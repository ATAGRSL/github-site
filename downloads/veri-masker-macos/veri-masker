#!/usr/bin/env node

/**
 * Lightweight data masking CLI for macOS demo builds.
 * Supports CSV/JSON inputs with configurable strategies.
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

const VERSION = '0.1.0';
const SUPPORTED_FORMATS = new Set(['csv', 'json']);
const SUPPORTED_STRATEGIES = new Set(['mask', 'hash', 'random', 'null']);
const DEFAULTS = {
  format: 'auto',
  strategy: 'mask',
  delimiter: ',',
  dryRun: false,
  salt: '',
};
const SCRIPT_DIR = __dirname;

function printHelp() {
  console.log(`veri-masker v${VERSION}

Kullanım:
  veri-masker --input data.csv --columns tc_kimlik,email --strategy mask
  veri-masker --profile config.json
  veri-masker --demo

Opsiyonlar:
  -i, --input <path>        Maskelenecek dosya (CSV veya JSON)
  -o, --output <path>       Çıktı dosyası (varsayılan: <input>-masked.ext)
  -c, --columns <list>      Maskelenecek kolonlar (virgülle ayrılmış)
  -s, --strategy <name>     mask | hash | random | null (default: mask)
  -f, --format <name>       csv | json | auto (default: auto)
  -d, --delimiter <char>    CSV ayırıcı (default: ,)
  --salt <value>            Hash stratejisi için ek tuz değeri
  --dry-run                 Dosya yazmadan önce özet göster
  --profile <path>          JSON konfigürasyon dosyası yükle
  --demo                    Örnek veri seti ile lokal demo çalıştır
  -h, --help                Yardım
  -v, --version             Sürümü göster
`);
}

function parseArgs(argv) {
  const options = {};
  for (let i = 0; i < argv.length; i++) {
    const arg = argv[i];
    switch (arg) {
      case '-i':
      case '--input':
        options.input = argv[++i];
        break;
      case '-o':
      case '--output':
        options.output = argv[++i];
        break;
      case '-c':
      case '--columns':
        options.columns = argv[++i];
        break;
      case '-s':
      case '--strategy':
        options.strategy = argv[++i];
        break;
      case '-f':
      case '--format':
        options.format = argv[++i];
        break;
      case '-d':
      case '--delimiter':
        options.delimiter = argv[++i];
        break;
      case '--salt':
        options.salt = argv[++i];
        break;
      case '--dry-run':
        options.dryRun = true;
        break;
      case '--profile':
        options.profile = argv[++i];
        break;
      case '--demo':
        options.demo = true;
        break;
      case '-h':
      case '--help':
        options.help = true;
        break;
      case '-v':
      case '--version':
        options.version = true;
        break;
      default:
        console.warn(`Bilinmeyen argüman atlandı: ${arg}`);
    }
  }
  return options;
}

function normalizeColumns(columns) {
  if (Array.isArray(columns)) {
    return columns.map((item) => String(item).trim()).filter(Boolean);
  }
  if (typeof columns === 'string') {
    return columns
      .split(',')
      .map((item) => item.trim())
      .filter(Boolean);
  }
  return [];
}

function detectFormat(inputPath, fallback = 'csv') {
  if (!inputPath) return fallback;
  const ext = path.extname(inputPath).toLowerCase();
  if (ext === '.json') return 'json';
  return 'csv';
}

function loadCsv(filePath, delimiter) {
  const raw = fs.readFileSync(filePath, 'utf8').trim();
  if (!raw) {
    return { headers: [], rows: [] };
  }
  const lines = raw.split(/\r?\n/);
  const headers = parseCsvLine(lines[0], delimiter);
  const rows = lines.slice(1).filter(Boolean).map((line, lineIndex) => {
    const cells = parseCsvLine(line, delimiter);
    const row = {};
    headers.forEach((header, idx) => {
      row[header] = cells[idx] ?? '';
    });
    if (cells.length > headers.length) {
      console.warn(
        `Satır ${lineIndex + 2} içindeki kolon sayısı başlıklardan fazla. Fazla veriler yok sayıldı.`
      );
    }
    return row;
  });
  return { headers, rows };
}

function saveCsv(filePath, data, rows, delimiter) {
  if (!data.headers.length) {
    fs.writeFileSync(filePath, '', 'utf8');
    return;
  }
  const headerLine = stringifyCsvLine(data.headers, delimiter);
  const body = rows
    .map((row) => {
      const cells = data.headers.map((header) => row[header] ?? '');
      return stringifyCsvLine(cells, delimiter);
    })
    .join('\n');
  fs.writeFileSync(filePath, `${headerLine}\n${body}\n`, 'utf8');
}

function parseCsvLine(line, delimiter) {
  const cells = [];
  let current = '';
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') {
        current += '"';
        i++;
      } else {
        inQuotes = !inQuotes;
      }
    } else if (char === delimiter && !inQuotes) {
      cells.push(current.trim());
      current = '';
    } else {
      current += char;
    }
  }
  cells.push(current.trim());
  return cells.map((value) => value.replace(/^"|"$/g, ''));
}

function stringifyCsvLine(cells, delimiter) {
  return cells
    .map((cell) => {
      if (cell === null || cell === undefined) return '';
      const needsQuotes = cell.includes(delimiter) || cell.includes('"') || /\r|\n/.test(cell);
      let value = String(cell).replace(/"/g, '""');
      if (needsQuotes) {
        value = `"${value}"`;
      }
      return value;
    })
    .join(delimiter);
}

function loadJson(filePath) {
  const raw = fs.readFileSync(filePath, 'utf8');
  const parsed = JSON.parse(raw);
  if (!Array.isArray(parsed)) {
    throw new Error('JSON girdisi bir dizi olmalı (ör. [{ "email": "..." }, ...])');
  }
  return parsed;
}

function maskDataset(rows, columns, strategy, salt) {
  let maskedCells = 0;
  const processed = rows.map((row) => {
    const clone = { ...row };
    columns.forEach((column) => {
      if (Object.prototype.hasOwnProperty.call(clone, column) && clone[column] != null) {
        clone[column] = maskValue(String(clone[column]), strategy, salt);
        maskedCells += 1;
      }
    });
    return clone;
  });

  return {
    rows: processed,
    report: {
      totalRows: rows.length,
      maskedCells,
      maskedColumns: columns,
      strategy,
    },
  };
}

function maskValue(value, strategy, salt) {
  switch (strategy) {
    case 'mask':
      if (value.length <= 4) {
        return '*'.repeat(value.length);
      }
      return `${value.slice(0, 2)}${'*'.repeat(Math.max(1, value.length - 4))}${value.slice(-2)}`;
    case 'hash':
      return crypto.createHash('sha256').update(value + (salt || '')).digest('hex');
    case 'random':
      return randomizeValue(value);
    case 'null':
      return 'REDACTED';
    default:
      throw new Error(`Desteklenmeyen strateji: ${strategy}`);
  }
}

function randomizeValue(value) {
  const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  const alphabetLower = alphabet.toLowerCase();
  const digits = '0123456789';
  let result = '';
  for (const char of value) {
    if (digits.includes(char)) {
      result += digits[Math.floor(Math.random() * digits.length)];
    } else if (alphabet.includes(char)) {
      result += alphabet[Math.floor(Math.random() * alphabet.length)];
    } else if (alphabetLower.includes(char)) {
      result += alphabetLower[Math.floor(Math.random() * alphabetLower.length)];
    } else {
      result += char;
    }
  }
  return result;
}

function ensureFile(pathToFile) {
  if (!fs.existsSync(pathToFile)) {
    throw new Error(`Dosya bulunamadı: ${pathToFile}`);
  }
}

function resolveProfile(profilePath) {
  const absolute = path.isAbsolute(profilePath)
    ? profilePath
    : path.join(process.cwd(), profilePath);
  ensureFile(absolute);
  return JSON.parse(fs.readFileSync(absolute, 'utf8'));
}

function ensureOutputDir(filePath) {
  const dir = path.dirname(filePath);
  fs.mkdirSync(dir, { recursive: true });
}

function printReport(report, outputPath) {
  console.log('\nMaskeleme Özeti');
  console.log('------------------------');
  console.log(`Satır sayısı    : ${report.totalRows}`);
  console.log(`Maskelenen hücre: ${report.maskedCells}`);
  console.log(`Kolonlar       : ${report.maskedColumns.join(', ')}`);
  console.log(`Strateji       : ${report.strategy}`);
  console.log(`Çıktı          : ${outputPath}`);
}

function main() {
  const cliOptions = parseArgs(process.argv.slice(2));

  if (cliOptions.help) {
    printHelp();
    process.exit(0);
  }

  if (cliOptions.version) {
    console.log(`veri-masker v${VERSION}`);
    process.exit(0);
  }

  let profileOptions = {};
  if (cliOptions.profile) {
    try {
      profileOptions = resolveProfile(String(cliOptions.profile));
    } catch (error) {
      console.error(`Profil yüklenemedi: ${error.message}`);
      process.exit(1);
    }
  }

  const options = {
    ...DEFAULTS,
    ...profileOptions,
    ...cliOptions,
  };

  if (!SUPPORTED_STRATEGIES.has(options.strategy)) {
    console.error(`Geçersiz strateji. Kullanılabilir değerler: ${Array.from(SUPPORTED_STRATEGIES).join(', ')}`);
    process.exit(1);
  }

  if (options.demo) {
    const demoInput = path.join(SCRIPT_DIR, 'sample-data', 'customers.csv');
    options.input = demoInput;
    options.format = 'csv';
    if (!options.columns) {
      options.columns = ['tc_kimlik', 'email', 'telefon'];
    }
    console.log('Demo modu: sample-data/customers.csv dosyası kullanılacak.');
  }

  if (!options.input) {
    console.error('Lütfen --input parametresi veya --demo bayrağı kullanın.');
    process.exit(1);
  }

  const absoluteInput = path.isAbsolute(options.input)
    ? options.input
    : path.join(process.cwd(), options.input);

  ensureFile(absoluteInput);

  const resolvedColumns = normalizeColumns(options.columns);
  if (!resolvedColumns.length) {
    console.error('Maskelenecek en az bir kolon belirtmelisiniz (--columns).');
    process.exit(1);
  }

  const format =
    options.format === 'auto' ? detectFormat(absoluteInput, 'csv') : String(options.format).toLowerCase();
  if (!SUPPORTED_FORMATS.has(format)) {
    console.error(`Geçersiz format. Desteklenen değerler: ${Array.from(SUPPORTED_FORMATS).join(', ')}`);
    process.exit(1);
  }

  const outputPath =
    options.output ||
    `${absoluteInput.replace(path.extname(absoluteInput), '')}-masked${path.extname(absoluteInput)}`;
  ensureOutputDir(outputPath);

  try {
    if (format === 'json') {
      const rows = loadJson(absoluteInput);
      const { rows: maskedRows, report } = maskDataset(rows, resolvedColumns, options.strategy, options.salt);
      if (!options.dryRun) {
        fs.writeFileSync(outputPath, JSON.stringify(maskedRows, null, 2), 'utf8');
      }
      printReport(report, options.dryRun ? '(dry-run)' : outputPath);
    } else {
      const data = loadCsv(absoluteInput, options.delimiter || ',');
      const { rows: maskedRows, report } = maskDataset(data.rows, resolvedColumns, options.strategy, options.salt);
      if (!options.dryRun) {
        saveCsv(outputPath, data, maskedRows, options.delimiter || ',');
      }
      printReport(report, options.dryRun ? '(dry-run)' : outputPath);
    }

    if (options.dryRun) {
      console.log('\nDry-run etkin: Dosya yazılmadı.');
    } else {
      console.log('Maskelenmiş çıktı başarıyla oluşturuldu.');
    }
  } catch (error) {
    console.error(`İşlem sırasında hata: ${error.message}`);
    process.exit(1);
  }
}

main();
